# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-performance` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-performance`.

# source://rubocop-performance//lib/rubocop/performance.rb#3
module RuboCop; end

# source://rubocop-performance//lib/rubocop/cop/mixin/regexp_metacharacter.rb#4
module RuboCop::Cop; end

# source://rubocop/1.39.0/lib/rubocop/cop/mixin/allowed_methods.rb#38
RuboCop::Cop::IgnoredMethods = RuboCop::Cop::AllowedMethods

# source://rubocop/1.39.0/lib/rubocop/cop/mixin/allowed_pattern.rb#54
RuboCop::Cop::IgnoredPattern = RuboCop::Cop::AllowedPattern

# source://rubocop-performance//lib/rubocop/cop/performance/ancestors_include.rb#5
module RuboCop::Cop::Performance; end

# This cop is used to identify usages of `ancestors.include?` and
# change them to use `<=` instead.
#
# @example
#   # bad
#   A.ancestors.include?(B)
#
#   # good
#   A <= B
#
# source://rubocop-performance//lib/rubocop/cop/performance/ancestors_include.rb#16
class RuboCop::Cop::Performance::AncestorsInclude < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/ancestors_include.rb#23
  def ancestors_include_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/ancestors_include.rb#27
  def on_send(node); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/ancestors_include.rb#40
  def range(node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/ancestors_include.rb#20
RuboCop::Cop::Performance::AncestorsInclude::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/ancestors_include.rb#21
RuboCop::Cop::Performance::AncestorsInclude::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies places where slicing arrays with semi-infinite ranges
# can be replaced by `Array#take` and `Array#drop`.
# This cop was created due to a mistake in microbenchmark and hence is disabled by default.
# Refer https://github.com/rubocop-hq/rubocop-performance/pull/175#issuecomment-731892717
# This cop is also unsafe for string slices because strings do not have `#take` and `#drop` methods.
#
# @example
#   # bad
#   # array[..2]
#   # array[...2]
#   # array[2..]
#   # array[2...]
#   # array.slice(..2)
#
#   # good
#   array.take(3)
#   array.take(2)
#   array.drop(2)
#   array.drop(2)
#   array.take(3)
#
# source://rubocop-performance//lib/rubocop/cop/performance/array_semi_infinite_range_slice.rb#27
class RuboCop::Cop::Performance::ArraySemiInfiniteRangeSlice < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop-performance//lib/rubocop/cop/performance/array_semi_infinite_range_slice.rb#43
  def endless_range?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/array_semi_infinite_range_slice.rb#39
  def endless_range_slice?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/array_semi_infinite_range_slice.rb#50
  def on_send(node); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/array_semi_infinite_range_slice.rb#63
  def correction(receiver, range_node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/array_semi_infinite_range_slice.rb#34
RuboCop::Cop::Performance::ArraySemiInfiniteRangeSlice::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/array_semi_infinite_range_slice.rb#37
RuboCop::Cop::Performance::ArraySemiInfiniteRangeSlice::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

# source://rubocop-performance//lib/rubocop/cop/performance/array_semi_infinite_range_slice.rb#36
RuboCop::Cop::Performance::ArraySemiInfiniteRangeSlice::SLICE_METHODS = T.let(T.unsafe(nil), Set)

# This cop identifies places where numeric argument to BigDecimal should be
# converted to string. Initializing from String is faster
# than from Numeric for BigDecimal.
#
# @example
#   # bad
#   BigDecimal(1, 2)
#   BigDecimal(1.2, 3, exception: true)
#
#   # good
#   BigDecimal('1', 2)
#   BigDecimal('1.2', 3, exception: true)
#
# source://rubocop-performance//lib/rubocop/cop/performance/big_decimal_with_numeric_argument.rb#19
class RuboCop::Cop::Performance::BigDecimalWithNumericArgument < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/big_decimal_with_numeric_argument.rb#25
  def big_decimal_with_numeric_argument?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/big_decimal_with_numeric_argument.rb#29
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/big_decimal_with_numeric_argument.rb#40
  def specifies_precision?(node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/big_decimal_with_numeric_argument.rb#22
RuboCop::Cop::Performance::BigDecimalWithNumericArgument::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/big_decimal_with_numeric_argument.rb#23
RuboCop::Cop::Performance::BigDecimalWithNumericArgument::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# In Ruby 2.7, `UnboundMethod#bind_call` has been added.
#
# This cop identifies places where `bind(obj).call(args, ...)`
# can be replaced by `bind_call(obj, args, ...)`.
#
# The `bind_call(obj, args, ...)` method is faster than
# `bind(obj).call(args, ...)`.
#
# @example
#   # bad
#   umethod.bind(obj).call(foo, bar)
#   umethod.bind(obj).(foo, bar)
#
#   # good
#   umethod.bind_call(obj, foo, bar)
#
# source://rubocop-performance//lib/rubocop/cop/performance/bind_call.rb#22
class RuboCop::Cop::Performance::BindCall < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop-performance//lib/rubocop/cop/performance/bind_call.rb#33
  def bind_with_call_method?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/bind_call.rb#41
  def on_send(node); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/bind_call.rb#72
  def build_call_args(call_args_node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/bind_call.rb#65
  def correction_range(receiver, node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/bind_call.rb#59
  def message(bind_arg, call_args); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/bind_call.rb#29
RuboCop::Cop::Performance::BindCall::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/bind_call.rb#31
RuboCop::Cop::Performance::BindCall::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies unnecessary use of a `block_given?` where explicit check
# of block argument would suffice.
#
# @example
#   # bad
#   def method(&block)
#   do_something if block_given?
#   end
#
#   # good
#   def method(&block)
#   do_something if block
#   end
#
#   # good - block is reassigned
#   def method(&block)
#   block ||= -> { do_something }
#   warn "Using default ..." unless block_given?
#   # ...
#   end
#
# source://rubocop-performance//lib/rubocop/cop/performance/block_given_with_explicit_block.rb#27
class RuboCop::Cop::Performance::BlockGivenWithExplicitBlock < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/block_given_with_explicit_block.rb#35
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/block_given_with_explicit_block.rb#33
  def reassigns_block_arg?(param0 = T.unsafe(nil), param1); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/block_given_with_explicit_block.rb#31
RuboCop::Cop::Performance::BlockGivenWithExplicitBlock::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/block_given_with_explicit_block.rb#30
RuboCop::Cop::Performance::BlockGivenWithExplicitBlock::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies places where `caller[n]`
# can be replaced by `caller(n..n).first`.
#
# @example
#   # bad
#   caller[1]
#   caller.first
#   caller_locations[1]
#   caller_locations.first
#
#   # good
#   caller(2..2).first
#   caller(1..1).first
#   caller_locations(2..2).first
#   caller_locations(1..1).first
#
# source://rubocop-performance//lib/rubocop/cop/performance/caller.rb#21
class RuboCop::Cop::Performance::Caller < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/caller.rb#34
  def caller_with_scope_method?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/caller.rb#41
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/caller.rb#27
  def slow_caller?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/caller.rb#62
  def int_value(node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/caller.rb#24
RuboCop::Cop::Performance::Caller::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/caller.rb#25
RuboCop::Cop::Performance::Caller::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Reordering `when` conditions with a splat to the end
# of the `when` branches can improve performance.
#
# Ruby has to allocate memory for the splat expansion every time
# that the `case` `when` statement is run. Since Ruby does not support
# fall through inside of `case` `when`, like some other languages do,
# the order of the `when` branches should not matter. By placing any
# splat expansions at the end of the list of `when` branches we will
# reduce the number of times that memory has to be allocated for
# the expansion. The exception to this is if multiple of your `when`
# conditions can be true for any given condition. A likely scenario for
# this defining a higher level when condition to override a condition
# that is inside of the splat expansion.
#
# This is not a guaranteed performance improvement. If the data being
# processed by the `case` condition is normalized in a manner that favors
# hitting a condition in the splat expansion, it is possible that
# moving the splat condition to the end will use more memory,
# and run slightly slower.
#
# @example
#   # bad
#   case foo
#   when *condition
#   bar
#   when baz
#   foobar
#   end
#
#   case foo
#   when *[1, 2, 3, 4]
#   bar
#   when 5
#   baz
#   end
#
#   # good
#   case foo
#   when baz
#   foobar
#   when *condition
#   bar
#   end
#
#   case foo
#   when 1, 2, 3, 4
#   bar
#   when 5
#   baz
#   end
#
# source://rubocop-performance//lib/rubocop/cop/performance/case_when_splat.rb#56
class RuboCop::Cop::Performance::CaseWhenSplat < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/case_when_splat.rb#66
  def on_case(case_node); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/case_when_splat.rb#83
  def autocorrect(corrector, when_node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/case_when_splat.rb#146
  def indent_for(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/case_when_splat.rb#100
  def inline_fix_branch(corrector, when_node); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/case_when_splat.rb#171
  def needs_reorder?(when_node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/case_when_splat.rb#141
  def new_branch_without_then(node, new_condition); end

  # source://rubocop-performance//lib/rubocop/cop/performance/case_when_splat.rb#136
  def new_condition_with_then(node, new_condition); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/case_when_splat.rb#164
  def non_splat?(condition); end

  # source://rubocop-performance//lib/rubocop/cop/performance/case_when_splat.rb#91
  def range(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/case_when_splat.rb#108
  def reorder_condition(corrector, when_node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/case_when_splat.rb#118
  def reordering_correction(when_node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/case_when_splat.rb#95
  def replacement(conditions); end

  # source://rubocop-performance//lib/rubocop/cop/performance/case_when_splat.rb#150
  def splat_offenses(when_conditions); end

  # source://rubocop-performance//lib/rubocop/cop/performance/case_when_splat.rb#128
  def when_branch_range(when_node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/case_when_splat.rb#63
RuboCop::Cop::Performance::CaseWhenSplat::ARRAY_MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/case_when_splat.rb#61
RuboCop::Cop::Performance::CaseWhenSplat::MSG = T.let(T.unsafe(nil), String)

# This cop identifies places where a case-insensitive string comparison
# can better be implemented using `casecmp`.
# This cop is unsafe because `String#casecmp` and `String#casecmp?` behave
# differently when using Non-ASCII characters.
#
# @example
#   # bad
#   str.downcase == 'abc'
#   str.upcase.eql? 'ABC'
#   'abc' == str.downcase
#   'ABC'.eql? str.upcase
#   str.downcase == str.downcase
#
#   # good
#   str.casecmp('ABC').zero?
#   'abc'.casecmp(str).zero?
#
# source://rubocop-performance//lib/rubocop/cop/performance/casecmp.rb#22
class RuboCop::Cop::Performance::Casecmp < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/casecmp.rb#43
  def downcase_downcase(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/casecmp.rb#29
  def downcase_eq(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/casecmp.rb#36
  def eq_downcase(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/casecmp.rb#50
  def on_send(node); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/casecmp.rb#90
  def build_good_method(arg, variable); end

  # source://rubocop-performance//lib/rubocop/cop/performance/casecmp.rb#82
  def correction(corrector, node, method, arg, variable); end

  # source://rubocop-performance//lib/rubocop/cop/performance/casecmp.rb#65
  def take_method_apart(node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/casecmp.rb#27
RuboCop::Cop::Performance::Casecmp::CASE_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-performance//lib/rubocop/cop/performance/casecmp.rb#25
RuboCop::Cop::Performance::Casecmp::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/casecmp.rb#26
RuboCop::Cop::Performance::Casecmp::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop is used to identify usages of
# Each of these methods (`compact`, `flatten`, `map`) will generate a
# new intermediate array that is promptly thrown away. Instead it is
# faster to mutate when we know it's safe.
#
# @example
#   # bad
#   array = ["a", "b", "c"]
#   array.compact.flatten.map { |x| x.downcase }
# @example
#   # good.
#   array = ["a", "b", "c"]
#   array.compact!
#   array.flatten!
#   array.map! { |x| x.downcase }
#   array
#
# source://rubocop-performance//lib/rubocop/cop/performance/chain_array_allocation.rb#23
class RuboCop::Cop::Performance::ChainArrayAllocation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop-performance//lib/rubocop/cop/performance/chain_array_allocation.rb#56
  def chain_array_allocation?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/chain_array_allocation.rb#64
  def on_send(node); end
end

# These methods ALWAYS return a new array
# after they're called it's safe to mutate the the resulting array
#
# source://rubocop-performance//lib/rubocop/cop/performance/chain_array_allocation.rb#39
RuboCop::Cop::Performance::ChainArrayAllocation::ALWAYS_RETURNS_NEW_ARRAY = T.let(T.unsafe(nil), Set)

# These methods have a mutation alternative. For example :collect
# can be called as :collect!
#
# source://rubocop-performance//lib/rubocop/cop/performance/chain_array_allocation.rb#47
RuboCop::Cop::Performance::ChainArrayAllocation::HAS_MUTATION_ALTERNATIVE = T.let(T.unsafe(nil), Set)

# source://rubocop-performance//lib/rubocop/cop/performance/chain_array_allocation.rb#52
RuboCop::Cop::Performance::ChainArrayAllocation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/chain_array_allocation.rb#50
RuboCop::Cop::Performance::ChainArrayAllocation::RETURNS_NEW_ARRAY = T.let(T.unsafe(nil), Set)

# These methods return a new array only when called without a block.
#
# source://rubocop-performance//lib/rubocop/cop/performance/chain_array_allocation.rb#35
RuboCop::Cop::Performance::ChainArrayAllocation::RETURNS_NEW_ARRAY_WHEN_NO_BLOCK = T.let(T.unsafe(nil), Set)

# These methods return a new array but only sometimes. They must be
# called with an argument. For example:
#
#   [1,2].first    # => 1
#   [1,2].first(1) # => [1]
#
# source://rubocop-performance//lib/rubocop/cop/performance/chain_array_allocation.rb#32
RuboCop::Cop::Performance::ChainArrayAllocation::RETURN_NEW_ARRAY_WHEN_ARGS = T.let(T.unsafe(nil), Set)

# This cop identifies places where Array and Hash literals are used
# within loops. It is better to extract them into a local variable or constant
# to avoid unnecessary allocations on each iteration.
#
# You can set the minimum number of elements to consider
# an offense with `MinSize`.
#
# @example
#   # bad
#   users.select do |user|
#   %i[superadmin admin].include?(user.role)
#   end
#
#   # good
#   admin_roles = %i[superadmin admin]
#   users.select do |user|
#   admin_roles.include?(user.role)
#   end
#
#   # good
#   ADMIN_ROLES = %i[superadmin admin]
#   ...
#   users.select do |user|
#   ADMIN_ROLES.include?(user.role)
#   end
#
# source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#34
class RuboCop::Cop::Performance::CollectionLiteralInLoop < ::RuboCop::Cop::Base
  # source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#74
  def enumerable_loop?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#68
  def kernel_loop?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#80
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#90
  def check_literal?(node, method); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#130
  def enumerable_method?(method_name); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#112
  def keyword_loop?(type); end

  # source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#122
  def literal_class(node); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#106
  def loop?(ancestor, node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#134
  def min_size; end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#116
  def node_within_enumerable_loop?(node, ancestor); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#97
  def nonmutable_method_of_array_or_hash?(node, method); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#102
  def parent_is_loop?(node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#56
RuboCop::Cop::Performance::CollectionLiteralInLoop::ARRAY_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#41
RuboCop::Cop::Performance::CollectionLiteralInLoop::ENUMERABLE_METHOD_NAMES = T.let(T.unsafe(nil), Set)

# source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#66
RuboCop::Cop::Performance::CollectionLiteralInLoop::HASH_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#39
RuboCop::Cop::Performance::CollectionLiteralInLoop::LOOP_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#35
RuboCop::Cop::Performance::CollectionLiteralInLoop::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#42
RuboCop::Cop::Performance::CollectionLiteralInLoop::NONMUTATING_ARRAY_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#58
RuboCop::Cop::Performance::CollectionLiteralInLoop::NONMUTATING_HASH_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-performance//lib/rubocop/cop/performance/collection_literal_in_loop.rb#38
RuboCop::Cop::Performance::CollectionLiteralInLoop::POST_CONDITION_LOOP_TYPES = T.let(T.unsafe(nil), Array)

# This cop identifies places where `sort { |a, b| a.foo <=> b.foo }`
# can be replaced by `sort_by(&:foo)`.
# This cop also checks `max` and `min` methods.
#
# @example
#   # bad
#   array.sort { |a, b| a.foo <=> b.foo }
#   array.max { |a, b| a.foo <=> b.foo }
#   array.min { |a, b| a.foo <=> b.foo }
#   array.sort { |a, b| a[:foo] <=> b[:foo] }
#
#   # good
#   array.sort_by(&:foo)
#   array.sort_by { |v| v.foo }
#   array.sort_by do |var|
#   var.foo
#   end
#   array.max_by(&:foo)
#   array.min_by(&:foo)
#   array.sort_by { |a| a[:foo] }
#
# source://rubocop-performance//lib/rubocop/cop/performance/compare_with_block.rb#26
class RuboCop::Cop::Performance::CompareWithBlock < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/compare_with_block.rb#34
  def compare?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/compare_with_block.rb#48
  def on_block(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/compare_with_block.rb#41
  def replaceable_body?(param0 = T.unsafe(nil), param1, param2); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/compare_with_block.rb#105
  def compare_range(send, node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/compare_with_block.rb#84
  def message(send, method, var_a, var_b, args); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/compare_with_block.rb#69
  def slow_compare?(method, args_a, args_b); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/compare_with_block.rb#30
RuboCop::Cop::Performance::CompareWithBlock::MSG = T.let(T.unsafe(nil), String)

# This cop finds regular expressions with dynamic components that are all constants.
#
# Ruby allocates a new Regexp object every time it executes a code containing such
# a regular expression. It is more efficient to extract it into a constant
# or add an `/o` option to perform `#{}` interpolation only once and reuse that
# Regexp object.
#
# @example
#
#   # bad
#   def tokens(pattern)
#   pattern.scan(TOKEN).reject { |token| token.match?(/\A#{SEPARATORS}\Z/) }
#   end
#
#   # good
#   ALL_SEPARATORS = /\A#{SEPARATORS}\Z/
#   def tokens(pattern)
#   pattern.scan(TOKEN).reject { |token| token.match?(ALL_SEPARATORS) }
#   end
#
#   # good
#   def tokens(pattern)
#   pattern.scan(TOKEN).reject { |token| token.match?(/\A#{SEPARATORS}\Z/o) }
#   end
#
# source://rubocop-performance//lib/rubocop/cop/performance/constant_regexp.rb#31
class RuboCop::Cop::Performance::ConstantRegexp < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/constant_regexp.rb#36
  def on_regexp(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/constant_regexp.rb#52
  def regexp_escape?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/constant_regexp.rb#57
  def include_interpolated_const?(node); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/constant_regexp.rb#48
  def within_const_assignment?(node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/constant_regexp.rb#34
RuboCop::Cop::Performance::ConstantRegexp::MSG = T.let(T.unsafe(nil), String)

# This cop is used to identify usages of `count` on an `Enumerable` that
# follow calls to `select`, `find_all`, `filter` or `reject`. Querying logic can instead be
# passed to the `count` call.
#
# `ActiveRecord` compatibility:
# `ActiveRecord` will ignore the block that is passed to `count`.
# Other methods, such as `select`, will convert the association to an
# array and then run the block on the array. A simple work around to
# make `count` work with a block is to call `to_a.count {...}`.
#
# Example:
#   `Model.where(id: [1, 2, 3]).select { |m| m.method == true }.size`
#
#   becomes:
#
#   `Model.where(id: [1, 2, 3]).to_a.count { |m| m.method == true }`
#
# @example
#   # bad
#   [1, 2, 3].select { |e| e > 2 }.size
#   [1, 2, 3].reject { |e| e > 2 }.size
#   [1, 2, 3].select { |e| e > 2 }.length
#   [1, 2, 3].reject { |e| e > 2 }.length
#   [1, 2, 3].select { |e| e > 2 }.count { |e| e.odd? }
#   [1, 2, 3].reject { |e| e > 2 }.count { |e| e.even? }
#   array.select(&:value).count
#
#   # good
#   [1, 2, 3].count { |e| e > 2 }
#   [1, 2, 3].count { |e| e < 2 }
#   [1, 2, 3].count { |e| e > 2 && e.odd? }
#   [1, 2, 3].count { |e| e < 2 && e.even? }
#   Model.select('field AS field_one').count
#   Model.select(:value).count
#
# source://rubocop-performance//lib/rubocop/cop/performance/count.rb#40
class RuboCop::Cop::Performance::Count < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/count.rb#47
  def count_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/count.rb#54
  def on_send(node); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/count.rb#70
  def autocorrect(corrector, node, selector_node, selector); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/count.rb#81
  def eligible_node?(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/count.rb#85
  def source_starting_at(node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/count.rb#44
RuboCop::Cop::Performance::Count::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/count.rb#45
RuboCop::Cop::Performance::Count::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# In Ruby 2.5, `String#delete_prefix` has been added.
#
# This cop identifies places where `gsub(/\Aprefix/, '')` and `sub(/\Aprefix/, '')`
# can be replaced by `delete_prefix('prefix')`.
#
# This cop has `SafeMultiline` configuration option that `true` by default because
# `^prefix` is unsafe as it will behave incompatible with `delete_prefix`
# for receiver is multiline string.
#
# The `delete_prefix('prefix')` method is faster than `gsub(/\Aprefix/, '')`.
#
# @example
#
#   # bad
#   str.gsub(/\Aprefix/, '')
#   str.gsub!(/\Aprefix/, '')
#
#   str.sub(/\Aprefix/, '')
#   str.sub!(/\Aprefix/, '')
#
#   # good
#   str.delete_prefix('prefix')
#   str.delete_prefix!('prefix')
# @example SafeMultiline: true (default)
#
#   # good
#   str.gsub(/^prefix/, '')
#   str.gsub!(/^prefix/, '')
#   str.sub(/^prefix/, '')
#   str.sub!(/^prefix/, '')
# @example SafeMultiline: false
#
#   # bad
#   str.gsub(/^prefix/, '')
#   str.gsub!(/^prefix/, '')
#   str.sub(/^prefix/, '')
#   str.sub!(/^prefix/, '')
#
# source://rubocop-performance//lib/rubocop/cop/performance/delete_prefix.rb#46
class RuboCop::Cop::Performance::DeletePrefix < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RegexpMetacharacter
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop-performance//lib/rubocop/cop/performance/delete_prefix.rb#63
  def delete_prefix_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/delete_prefix.rb#67
  def on_send(node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/delete_prefix.rb#53
RuboCop::Cop::Performance::DeletePrefix::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/delete_prefix.rb#56
RuboCop::Cop::Performance::DeletePrefix::PREFERRED_METHODS = T.let(T.unsafe(nil), Hash)

# source://rubocop-performance//lib/rubocop/cop/performance/delete_prefix.rb#54
RuboCop::Cop::Performance::DeletePrefix::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# In Ruby 2.5, `String#delete_suffix` has been added.
#
# This cop identifies places where `gsub(/suffix\z/, '')` and `sub(/suffix\z/, '')`
# can be replaced by `delete_suffix('suffix')`.
#
# This cop has `SafeMultiline` configuration option that `true` by default because
# `suffix$` is unsafe as it will behave incompatible with `delete_suffix?`
# for receiver is multiline string.
#
# The `delete_suffix('suffix')` method is faster than `gsub(/suffix\z/, '')`.
#
# @example
#
#   # bad
#   str.gsub(/suffix\z/, '')
#   str.gsub!(/suffix\z/, '')
#
#   str.sub(/suffix\z/, '')
#   str.sub!(/suffix\z/, '')
#
#   # good
#   str.delete_suffix('suffix')
#   str.delete_suffix!('suffix')
# @example SafeMultiline: true (default)
#
#   # good
#   str.gsub(/suffix$/, '')
#   str.gsub!(/suffix$/, '')
#   str.sub(/suffix$/, '')
#   str.sub!(/suffix$/, '')
# @example SafeMultiline: false
#
#   # bad
#   str.gsub(/suffix$/, '')
#   str.gsub!(/suffix$/, '')
#   str.sub(/suffix$/, '')
#   str.sub!(/suffix$/, '')
#
# source://rubocop-performance//lib/rubocop/cop/performance/delete_suffix.rb#46
class RuboCop::Cop::Performance::DeleteSuffix < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RegexpMetacharacter
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  # source://rubocop-performance//lib/rubocop/cop/performance/delete_suffix.rb#63
  def delete_suffix_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/delete_suffix.rb#67
  def on_send(node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/delete_suffix.rb#53
RuboCop::Cop::Performance::DeleteSuffix::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/delete_suffix.rb#56
RuboCop::Cop::Performance::DeleteSuffix::PREFERRED_METHODS = T.let(T.unsafe(nil), Hash)

# source://rubocop-performance//lib/rubocop/cop/performance/delete_suffix.rb#54
RuboCop::Cop::Performance::DeleteSuffix::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop is used to identify usages of `first`, `last`, `[0]` or `[-1]`
# chained to `select`, `find_all` or `filter` and change them to use
# `detect` instead.
#
# `ActiveRecord` compatibility:
# `ActiveRecord` does not implement a `detect` method and `find` has its
# own meaning. Correcting ActiveRecord methods with this cop should be
# considered unsafe.
#
# @example
#   # bad
#   [].select { |item| true }.first
#   [].select { |item| true }.last
#   [].find_all { |item| true }.first
#   [].find_all { |item| true }.last
#   [].filter { |item| true }.first
#   [].filter { |item| true }.last
#   [].filter { |item| true }[0]
#   [].filter { |item| true }[-1]
#
#   # good
#   [].detect { |item| true }
#   [].reverse.detect { |item| true }
#
# source://rubocop-performance//lib/rubocop/cop/performance/detect.rb#29
class RuboCop::Cop::Performance::Detect < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/detect.rb#44
  def detect_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/detect.rb#53
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/detect.rb#72
  def accept_first_call?(receiver, body); end

  # source://rubocop-performance//lib/rubocop/cop/performance/detect.rb#104
  def autocorrect(corrector, node, replacement); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/detect.rb#130
  def lazy?(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/detect.rb#115
  def message_for_method(method, index); end

  # source://rubocop-performance//lib/rubocop/cop/performance/detect.rb#126
  def preferred_method; end

  # source://rubocop-performance//lib/rubocop/cop/performance/detect.rb#81
  def register_offense(node, receiver, second_method, index); end

  # source://rubocop-performance//lib/rubocop/cop/performance/detect.rb#96
  def replacement(method, index); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/detect.rb#32
RuboCop::Cop::Performance::Detect::CANDIDATE_METHODS = T.let(T.unsafe(nil), Set)

# source://rubocop-performance//lib/rubocop/cop/performance/detect.rb#38
RuboCop::Cop::Performance::Detect::INDEX_MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/detect.rb#40
RuboCop::Cop::Performance::Detect::INDEX_REVERSE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/detect.rb#34
RuboCop::Cop::Performance::Detect::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/detect.rb#42
RuboCop::Cop::Performance::Detect::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-performance//lib/rubocop/cop/performance/detect.rb#36
RuboCop::Cop::Performance::Detect::REVERSE_MSG = T.let(T.unsafe(nil), String)

# This cop checks for double `#start_with?` or `#end_with?` calls
# separated by `||`. In some cases such calls can be replaced
# with an single `#start_with?`/`#end_with?` call.
#
# @example
#   # bad
#   str.start_with?("a") || str.start_with?(Some::CONST)
#   str.start_with?("a", "b") || str.start_with?("c")
#   str.end_with?(var1) || str.end_with?(var2)
#
#   # good
#   str.start_with?("a", Some::CONST)
#   str.start_with?("a", "b", "c")
#   str.end_with?(var1, var2)
#
# source://rubocop-performance//lib/rubocop/cop/performance/double_start_end_with.rb#20
class RuboCop::Cop::Performance::DoubleStartEndWith < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/double_start_end_with.rb#76
  def check_with_active_support_aliases(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/double_start_end_with.rb#26
  def on_or(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/double_start_end_with.rb#70
  def two_start_end_with_calls(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/double_start_end_with.rb#40
  def autocorrect(corrector, first_call_args, second_call_args, combined_args); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/double_start_end_with.rb#66
  def check_for_active_support_aliases?; end

  # source://rubocop-performance//lib/rubocop/cop/performance/double_start_end_with.rb#62
  def combine_args(first_call_args, second_call_args); end

  # source://rubocop-performance//lib/rubocop/cop/performance/double_start_end_with.rb#56
  def message(node, receiver, method, combined_args); end

  # source://rubocop-performance//lib/rubocop/cop/performance/double_start_end_with.rb#48
  def process_source(node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/double_start_end_with.rb#23
RuboCop::Cop::Performance::DoubleStartEndWith::MSG = T.let(T.unsafe(nil), String)

# This cop identifies unnecessary use of a regex where `String#end_with?` would suffice.
#
# This cop has `SafeMultiline` configuration option that `true` by default because
# `end$` is unsafe as it will behave incompatible with `end_with?`
# for receiver is multiline string.
#
# @example
#   # bad
#   'abc'.match?(/bc\Z/)
#   /bc\Z/.match?('abc')
#   'abc' =~ /bc\Z/
#   /bc\Z/ =~ 'abc'
#   'abc'.match(/bc\Z/)
#   /bc\Z/.match('abc')
#
#   # good
#   'abc'.end_with?('bc')
# @example SafeMultiline: true (default)
#
#   # good
#   'abc'.match?(/bc$/)
#   /bc$/.match?('abc')
#   'abc' =~ /bc$/
#   /bc$/ =~ 'abc'
#   'abc'.match(/bc$/)
#   /bc$/.match('abc')
# @example SafeMultiline: false
#
#   # bad
#   'abc'.match?(/bc$/)
#   /bc$/.match?('abc')
#   'abc' =~ /bc$/
#   /bc$/ =~ 'abc'
#   'abc'.match(/bc$/)
#   /bc$/.match('abc')
#
# source://rubocop-performance//lib/rubocop/cop/performance/end_with.rb#44
class RuboCop::Cop::Performance::EndWith < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RegexpMetacharacter
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/end_with.rb#58
  def on_match_with_lvasgn(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/end_with.rb#58
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/end_with.rb#52
  def redundant_regex?(param0 = T.unsafe(nil)); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/end_with.rb#48
RuboCop::Cop::Performance::EndWith::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/end_with.rb#50
RuboCop::Cop::Performance::EndWith::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Do not compute the size of statically sized objects.
#
# @example
#   # String methods
#   # bad
#   'foo'.size
#   %q[bar].count
#   %(qux).length
#
#   # Symbol methods
#   # bad
#   :fred.size
#   :'baz'.length
#
#   # Array methods
#   # bad
#   [1, 2, thud].count
#   %W(1, 2, bar).size
#
#   # Hash methods
#   # bad
#   { a: corge, b: grault }.length
#
#   # good
#   foo.size
#   bar.count
#   qux.length
#
#   # good
#   :"#{fred}".size
#   CONST = :baz.length
#
#   # good
#   [1, 2, *thud].count
#   garply = [1, 2, 3]
#   garply.size
#
#   # good
#   { a: corge, **grault }.length
#   waldo = { a: corge, b: grault }
#   waldo.size
#
# source://rubocop-performance//lib/rubocop/cop/performance/fixed_size.rb#48
class RuboCop::Cop::Performance::FixedSize < ::RuboCop::Cop::Base
  # source://rubocop-performance//lib/rubocop/cop/performance/fixed_size.rb#52
  def counter(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/fixed_size.rb#56
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/fixed_size.rb#72
  def allowed_argument?(arg); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/fixed_size.rb#76
  def allowed_parent?(node); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/fixed_size.rb#68
  def allowed_variable?(var); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/fixed_size.rb#86
  def contains_double_splat?(node); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/fixed_size.rb#80
  def contains_splat?(node); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/fixed_size.rb#92
  def non_string_argument?(node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/fixed_size.rb#49
RuboCop::Cop::Performance::FixedSize::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/fixed_size.rb#50
RuboCop::Cop::Performance::FixedSize::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop is used to identify usages of
#
# @example
#   # bad
#   [1, 2, 3, 4].map { |e| [e, e] }.flatten(1)
#   [1, 2, 3, 4].collect { |e| [e, e] }.flatten(1)
#
#   # good
#   [1, 2, 3, 4].flat_map { |e| [e, e] }
#   [1, 2, 3, 4].map { |e| [e, e] }.flatten
#   [1, 2, 3, 4].collect { |e| [e, e] }.flatten
#
# source://rubocop-performance//lib/rubocop/cop/performance/flat_map.rb#17
class RuboCop::Cop::Performance::FlatMap < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/flat_map.rb#27
  def flat_map_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/flat_map.rb#38
  def on_send(node); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/flat_map.rb#70
  def autocorrect(corrector, node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/flat_map.rb#51
  def offense_for_levels(node, map_node, first_method, flatten); end

  # source://rubocop-performance//lib/rubocop/cop/performance/flat_map.rb#57
  def offense_for_method(node, map_node, first_method, flatten); end

  # source://rubocop-performance//lib/rubocop/cop/performance/flat_map.rb#61
  def register_offense(node, map_node, first_method, flatten, message); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/flat_map.rb#23
RuboCop::Cop::Performance::FlatMap::FLATTEN_MULTIPLE_LEVELS = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/flat_map.rb#21
RuboCop::Cop::Performance::FlatMap::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/flat_map.rb#22
RuboCop::Cop::Performance::FlatMap::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for inefficient searching of keys and values within
# hashes.
#
# `Hash#keys.include?` is less efficient than `Hash#key?` because
# the former allocates a new array and then performs an O(n) search
# through that array, while `Hash#key?` does not allocate any array and
# performs a faster O(1) search for the key.
#
# `Hash#values.include?` is less efficient than `Hash#value?`. While they
# both perform an O(n) search through all of the values, calling `values`
# allocates a new array while using `value?` does not.
#
# @example
#   # bad
#   { a: 1, b: 2 }.keys.include?(:a)
#   { a: 1, b: 2 }.keys.include?(:z)
#   h = { a: 1, b: 2 }; h.keys.include?(100)
#
#   # good
#   { a: 1, b: 2 }.key?(:a)
#   { a: 1, b: 2 }.has_key?(:z)
#   h = { a: 1, b: 2 }; h.key?(100)
#
#   # bad
#   { a: 1, b: 2 }.values.include?(2)
#   { a: 1, b: 2 }.values.include?('garbage')
#   h = { a: 1, b: 2 }; h.values.include?(nil)
#
#   # good
#   { a: 1, b: 2 }.value?(2)
#   { a: 1, b: 2 }.has_value?('garbage')
#   h = { a: 1, b: 2 }; h.value?(nil)
#
# source://rubocop-performance//lib/rubocop/cop/performance/inefficient_hash_search.rb#39
class RuboCop::Cop::Performance::InefficientHashSearch < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/inefficient_hash_search.rb#44
  def inefficient_include?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/inefficient_hash_search.rb#48
  def on_send(node); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/inefficient_hash_search.rb#90
  def autocorrect_argument(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/inefficient_hash_search.rb#94
  def autocorrect_hash_expression(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/inefficient_hash_search.rb#72
  def autocorrect_method(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/inefficient_hash_search.rb#79
  def current_method(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/inefficient_hash_search.rb#67
  def message(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/inefficient_hash_search.rb#83
  def use_long_method; end
end

# source://rubocop-performance//lib/rubocop/cop/performance/inefficient_hash_search.rb#42
RuboCop::Cop::Performance::InefficientHashSearch::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies places where inefficient `readlines` method
# can be replaced by `each_line` to avoid fully loading file content into memory.
#
# @example
#
#   # bad
#   File.readlines('testfile').each { |l| puts l }
#   IO.readlines('testfile', chomp: true).each { |l| puts l }
#
#   conn.readlines(10).map { |l| l.size }
#   file.readlines.find { |l| l.start_with?('#') }
#   file.readlines.each { |l| puts l }
#
#   # good
#   File.open('testfile', 'r').each_line { |l| puts l }
#   IO.open('testfile').each_line(chomp: true) { |l| puts l }
#
#   conn.each_line(10).map { |l| l.size }
#   file.each_line.find { |l| l.start_with?('#') }
#   file.each_line { |l| puts l }
#
# source://rubocop-performance//lib/rubocop/cop/performance/io_readlines.rb#27
class RuboCop::Cop::Performance::IoReadlines < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/io_readlines.rb#42
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/io_readlines.rb#34
  def readlines_on_class?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/io_readlines.rb#38
  def readlines_on_instance?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/io_readlines.rb#58
  def autocorrect(corrector, enumerable_call, readlines_call, receiver); end

  # source://rubocop-performance//lib/rubocop/cop/performance/io_readlines.rb#90
  def build_bad_method(enumerable_call); end

  # source://rubocop-performance//lib/rubocop/cop/performance/io_readlines.rb#106
  def build_call_args(call_args_node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/io_readlines.rb#82
  def build_good_method(enumerable_call); end

  # source://rubocop-performance//lib/rubocop/cop/performance/io_readlines.rb#94
  def correction_range(enumerable_call, readlines_call); end

  # source://rubocop-performance//lib/rubocop/cop/performance/io_readlines.rb#76
  def offense_range(enumerable_call, readlines_call); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/io_readlines.rb#31
RuboCop::Cop::Performance::IoReadlines::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/io_readlines.rb#32
RuboCop::Cop::Performance::IoReadlines::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies places where methods are converted to blocks, with the
# use of `&method`, and passed as arguments to method calls.
# It is faster to replace those with explicit blocks, calling those methods inside.
#
# @example
#   # bad
#   array.map(&method(:do_something))
#   [1, 2, 3].each(&out.method(:puts))
#
#   # good
#   array.map { |x| do_something(x) }
#   [1, 2, 3].each { |x| out.puts(x) }
#
# source://rubocop-performance//lib/rubocop/cop/performance/method_object_as_block.rb#19
class RuboCop::Cop::Performance::MethodObjectAsBlock < ::RuboCop::Cop::Base
  # source://rubocop-performance//lib/rubocop/cop/performance/method_object_as_block.rb#22
  def method_object_as_argument?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/method_object_as_block.rb#26
  def on_block_pass(node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/method_object_as_block.rb#20
RuboCop::Cop::Performance::MethodObjectAsBlock::MSG = T.let(T.unsafe(nil), String)

# This cop checks for `OpenStruct.new` calls.
# Instantiation of an `OpenStruct` invalidates
# Ruby global method cache as it causes dynamic method
# definition during program runtime.
# This could have an effect on performance,
# especially in case of single-threaded
# applications with multiple `OpenStruct` instantiations.
#
# @example
#   # bad
#   class MyClass
#   def my_method
#   OpenStruct.new(my_key1: 'my_value1', my_key2: 'my_value2')
#   end
#   end
#
#   # good
#   class MyClass
#   MyStruct = Struct.new(:my_key1, :my_key2)
#   def my_method
#   MyStruct.new('my_value1', 'my_value2')
#   end
#   end
#
# source://rubocop-performance//lib/rubocop/cop/performance/open_struct.rb#30
class RuboCop::Cop::Performance::OpenStruct < ::RuboCop::Cop::Base
  # source://rubocop-performance//lib/rubocop/cop/performance/open_struct.rb#39
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/open_struct.rb#35
  def open_struct(param0 = T.unsafe(nil)); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/open_struct.rb#31
RuboCop::Cop::Performance::OpenStruct::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/open_struct.rb#33
RuboCop::Cop::Performance::OpenStruct::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies uses of `Range#include?` and `Range#member?`, which iterates over each
# item in a `Range` to see if a specified item is there. In contrast,
# `Range#cover?` simply compares the target item with the beginning and
# end points of the `Range`. In a great majority of cases, this is what
# is wanted.
#
# This cop is `Safe: false` by default because `Range#include?` (or `Range#member?`) and
# `Range#cover?` are not equivalent behaviour.
#
# @example
#   # bad
#   ('a'..'z').include?('b') # => true
#   ('a'..'z').member?('b')  # => true
#
#   # good
#   ('a'..'z').cover?('b') # => true
#
#   # Example of a case where `Range#cover?` may not provide
#   # the desired result:
#
#   ('a'..'z').cover?('yellow') # => true
#
# source://rubocop-performance//lib/rubocop/cop/performance/range_include.rb#27
class RuboCop::Cop::Performance::RangeInclude < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/range_include.rb#42
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/range_include.rb#38
  def range_include(param0 = T.unsafe(nil)); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/range_include.rb#30
RuboCop::Cop::Performance::RangeInclude::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/range_include.rb#31
RuboCop::Cop::Performance::RangeInclude::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies the use of a `&block` parameter and `block.call`
# where `yield` would do just as well.
#
# @example
#   # bad
#   def method(&block)
#   block.call
#   end
#   def another(&func)
#   func.call 1, 2, 3
#   end
#
#   # good
#   def method
#   yield
#   end
#   def another
#   yield 1, 2, 3
#   end
#
# source://rubocop-performance//lib/rubocop/cop/performance/redundant_block_call.rb#25
class RuboCop::Cop::Performance::RedundantBlockCall < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_block_call.rb#43
  def blockarg_assigned?(param0, param1); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_block_call.rb#39
  def blockarg_calls(param0, param1); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_block_call.rb#34
  def blockarg_def(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_block_call.rb#47
  def on_def(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_block_call.rb#90
  def args_include_block_pass?(blockcall); end

  # offenses are registered on the `block.call` nodes
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_block_call.rb#62
  def autocorrect(corrector, node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_block_call.rb#80
  def calls_to_report(argname, body); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/redundant_block_call.rb#31
RuboCop::Cop::Performance::RedundantBlockCall::CLOSE_PAREN = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/redundant_block_call.rb#28
RuboCop::Cop::Performance::RedundantBlockCall::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/redundant_block_call.rb#30
RuboCop::Cop::Performance::RedundantBlockCall::OPEN_PAREN = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/redundant_block_call.rb#32
RuboCop::Cop::Performance::RedundantBlockCall::SPACE = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/redundant_block_call.rb#29
RuboCop::Cop::Performance::RedundantBlockCall::YIELD = T.let(T.unsafe(nil), String)

# This cop identifies the use of `Regexp#match` or `String#match`, which
# returns `#<MatchData>`/`nil`. The return value of `=~` is an integral
# index/`nil` and is more performant.
#
# @example
#   # bad
#   do_something if str.match(/regex/)
#   while regex.match('str')
#   do_something
#   end
#
#   # good
#   method(str =~ /regex/)
#   return value unless regex =~ 'str'
#
# source://rubocop-performance//lib/rubocop/cop/performance/redundant_match.rb#20
class RuboCop::Cop::Performance::RedundantMatch < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_match.rb#29
  def match_call?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_match.rb#38
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_match.rb#34
  def only_truthiness_matters?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_match.rb#50
  def autocorrect(corrector, node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/redundant_match.rb#23
RuboCop::Cop::Performance::RedundantMatch::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/redundant_match.rb#25
RuboCop::Cop::Performance::RedundantMatch::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies places where `Hash#merge!` can be replaced by
# `Hash#[]=`.
# You can set the maximum number of key-value pairs to consider
# an offense with `MaxKeyValuePairs`.
#
# @example
#   # bad
#   hash.merge!(a: 1)
#   hash.merge!({'key' => 'value'})
#
#   # good
#   hash[:a] = 1
#   hash['key'] = 'value'
# @example MaxKeyValuePairs: 2 (default)
#   # bad
#   hash.merge!(a: 1, b: 2)
#
#   # good
#   hash[:a] = 1
#   hash[:b] = 2
#
# source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#27
class RuboCop::Cop::Performance::RedundantMerge < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#44
  def modifier_flow_control?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#48
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#40
  def redundant_merge_candidate(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#103
  def correct_multiple_elements(corrector, node, parent, new_source); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#115
  def correct_single_element(corrector, node, new_source); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#75
  def each_redundant_merge(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#147
  def indent_width; end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#94
  def kwsplat_used?(pairs); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#143
  def leading_spaces(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#151
  def max_key_value_pairs; end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#67
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#83
  def non_redundant_merge?(node, receiver, pairs); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#90
  def non_redundant_pairs?(receiver, pairs); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#98
  def non_redundant_value_used?(receiver, node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#131
  def rewrite_with_modifier(node, parent, new_source); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#119
  def to_assignments(receiver, pairs); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#30
RuboCop::Cop::Performance::RedundantMerge::AREF_ASGN = T.let(T.unsafe(nil), String)

# A utility class for checking the use of values within an
# `each_with_object` call.
#
# source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#157
class RuboCop::Cop::Performance::RedundantMerge::EachWithObjectInspector
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [EachWithObjectInspector] a new instance of EachWithObjectInspector
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#160
  def initialize(node, receiver); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#191
  def each_with_object_node(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#165
  def value_used?; end

  private

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#175
  def eligible_receiver?; end

  # Returns the value of attribute node.
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#173
  def node; end

  # Returns the value of attribute receiver.
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#173
  def receiver; end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#179
  def second_argument; end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#186
  def unwind(receiver); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#31
RuboCop::Cop::Performance::RedundantMerge::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#32
RuboCop::Cop::Performance::RedundantMerge::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-performance//lib/rubocop/cop/performance/redundant_merge.rb#34
RuboCop::Cop::Performance::RedundantMerge::WITH_MODIFIER_CORRECTION = T.let(T.unsafe(nil), String)

# This cop identifies places where `sort { |a, b| a <=> b }`
# can be replaced with `sort`.
#
# @example
#   # bad
#   array.sort { |a, b| a <=> b }
#
#   # good
#   array.sort
#
# source://rubocop-performance//lib/rubocop/cop/performance/redundant_sort_block.rb#16
class RuboCop::Cop::Performance::RedundantSortBlock < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SortBlock
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_sort_block.rb#22
  def on_block(node); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_sort_block.rb#36
  def message(var_a, var_b); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/redundant_sort_block.rb#20
RuboCop::Cop::Performance::RedundantSortBlock::MSG = T.let(T.unsafe(nil), String)

# This cop checks for redundant `String#chars`.
#
# @example
#   # bad
#   str.chars[0..2]
#   str.chars.slice(0..2)
#
#   # good
#   str[0..2].chars
#
#   # bad
#   str.chars.first
#   str.chars.first(2)
#   str.chars.last
#   str.chars.last(2)
#
#   # good
#   str[0]
#   str[0...2].chars
#   str[-1]
#   str[-2..-1].chars
#
#   # bad
#   str.chars.take(2)
#   str.chars.drop(2)
#   str.chars.length
#   str.chars.size
#   str.chars.empty?
#
#   # good
#   str[0...2].chars
#   str[2..-1].chars
#   str.length
#   str.size
#   str.empty?
#
# source://rubocop-performance//lib/rubocop/cop/performance/redundant_string_chars.rb#42
class RuboCop::Cop::Performance::RedundantStringChars < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_string_chars.rb#53
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_string_chars.rb#49
  def redundant_chars_call?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_string_chars.rb#110
  def build_bad_method(method, args); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_string_chars.rb#123
  def build_call_args(call_args_node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_string_chars.rb#84
  def build_good_method(method, args); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_string_chars.rb#77
  def build_message(method, args); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_string_chars.rb#73
  def correction_range(receiver, node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/redundant_string_chars.rb#69
  def offense_range(receiver, node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/redundant_string_chars.rb#46
RuboCop::Cop::Performance::RedundantStringChars::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/redundant_string_chars.rb#47
RuboCop::Cop::Performance::RedundantStringChars::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# In Ruby 2.4, `String#match?`, `Regexp#match?`, and `Symbol#match?`
# have been added. The methods are faster than `match`.
# Because the methods avoid creating a `MatchData` object or saving
# backref.
# So, when `MatchData` is not used, use `match?` instead of `match`.
#
# @example
#   # bad
#   def foo
#   if x =~ /re/
#   do_something
#   end
#   end
#
#   # bad
#   def foo
#   if x !~ /re/
#   do_something
#   end
#   end
#
#   # bad
#   def foo
#   if x.match(/re/)
#   do_something
#   end
#   end
#
#   # bad
#   def foo
#   if /re/ === x
#   do_something
#   end
#   end
#
#   # good
#   def foo
#   if x.match?(/re/)
#   do_something
#   end
#   end
#
#   # good
#   def foo
#   if !x.match?(/re/)
#   do_something
#   end
#   end
#
#   # good
#   def foo
#   if x =~ /re/
#   do_something(Regexp.last_match)
#   end
#   end
#
#   # good
#   def foo
#   if x.match(/re/)
#   do_something($~)
#   end
#   end
#
#   # good
#   def foo
#   if /re/ === x
#   do_something($~)
#   end
#   end
#
# source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#75
class RuboCop::Cop::Performance::RegexpMatch < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#123
  def last_matches(param0); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#84
  def match_method?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#120
  def match_node?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#95
  def match_operator?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#99
  def match_threequals?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#91
  def match_with_int_arg_method?(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#103
  def match_with_lvasgn?(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#136
  def on_case(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#132
  def on_if(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#121
  def search_match_nodes(param0); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#159
  def autocorrect(corrector, node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#148
  def check_condition(cond); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#252
  def correct_operator(corrector, recv, arg, oper = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#277
  def correction_range(recv, arg); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#215
  def find_last_match(body, range, scope_root); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#175
  def last_match_used?(match_node); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#241
  def match_gvar?(sym); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#171
  def message(node); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#211
  def modifier_form?(match_node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#197
  def next_match_pos(body, match_node_pos, scope_root); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#184
  def range_to_search_for_last_matches(match_node, body, scope_root); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#261
  def replace_with_match_predicate_method(corrector, recv, arg, op_range); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#223
  def scope_body(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#235
  def scope_root(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#272
  def swap_receiver_and_arg(corrector, recv, arg); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#110
RuboCop::Cop::Performance::RegexpMatch::MATCH_NODE_PATTERN = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#81
RuboCop::Cop::Performance::RegexpMatch::MSG = T.let(T.unsafe(nil), String)

# Constants are included in this list because it is unlikely that
# someone will store `nil` as a constant and then use it for comparison
#
# source://rubocop-performance//lib/rubocop/cop/performance/regexp_match.rb#80
RuboCop::Cop::Performance::RegexpMatch::TYPES_IMPLEMENTING_MATCH = T.let(T.unsafe(nil), Array)

# This cop is used to identify usages of `reverse.each` and
# change them to use `reverse_each` instead.
#
# @example
#   # bad
#   [].reverse.each
#
#   # good
#   [].reverse_each
#
# source://rubocop-performance//lib/rubocop/cop/performance/reverse_each.rb#15
class RuboCop::Cop::Performance::ReverseEach < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/reverse_each.rb#27
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/reverse_each.rb#23
  def reverse_each?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/reverse_each.rb#42
  def replacement_range(node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/reverse_each.rb#19
RuboCop::Cop::Performance::ReverseEach::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/reverse_each.rb#20
RuboCop::Cop::Performance::ReverseEach::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-performance//lib/rubocop/cop/performance/reverse_each.rb#21
RuboCop::Cop::Performance::ReverseEach::UNDERSCORE = T.let(T.unsafe(nil), String)

# This cop identifies places where `reverse.first(n)` and `reverse.first`
# can be replaced by `last(n).reverse` and `last`.
#
# @example
#
#   # bad
#   array.reverse.first(5)
#   array.reverse.first
#
#   # good
#   array.last(5).reverse
#   array.last
#
# source://rubocop-performance//lib/rubocop/cop/performance/reverse_first.rb#19
class RuboCop::Cop::Performance::ReverseFirst < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/reverse_first.rb#30
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/reverse_first.rb#26
  def reverse_first_candidate?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/reverse_first.rb#63
  def build_bad_method(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/reverse_first.rb#55
  def build_good_method(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/reverse_first.rb#49
  def build_message(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/reverse_first.rb#45
  def correction_range(receiver, node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/reverse_first.rb#23
RuboCop::Cop::Performance::ReverseFirst::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/reverse_first.rb#24
RuboCop::Cop::Performance::ReverseFirst::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop is used to identify usages of `count` on an
# `Array` and `Hash` and change them to `size`.
#
# TODO: Add advanced detection of variables that could
# have been assigned to an array or a hash.
#
# @example
#   # bad
#   [1, 2, 3].count
#   (1..3).to_a.count
#   Array[*1..3].count
#   Array(1..3).count
#
#   # bad
#   {a: 1, b: 2, c: 3}.count
#   [[:foo, :bar], [1, 2]].to_h.count
#   Hash[*('a'..'z')].count
#   Hash(key: :value).count
#
#   # good
#   [1, 2, 3].size
#   (1..3).to_a.size
#   Array[*1..3].size
#   Array(1..3).size
#
#   # good
#   {a: 1, b: 2, c: 3}.size
#   [[:foo, :bar], [1, 2]].to_h.size
#   Hash[*('a'..'z')].size
#   Hash(key: :value).size
#
#   # good
#   [1, 2, 3].count { |e| e > 2 }
#
# source://rubocop-performance//lib/rubocop/cop/performance/size.rb#38
class RuboCop::Cop::Performance::Size < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/size.rb#44
  def array?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/size.rb#62
  def count?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/size.rb#53
  def hash?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/size.rb#66
  def on_send(node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/size.rb#41
RuboCop::Cop::Performance::Size::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/size.rb#42
RuboCop::Cop::Performance::Size::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies places where `sort { |a, b| b <=> a }`
# can be replaced by a faster `sort.reverse`.
#
# @example
#   # bad
#   array.sort { |a, b| b <=> a }
#
#   # good
#   array.sort.reverse
#
# source://rubocop-performance//lib/rubocop/cop/performance/sort_reverse.rb#16
class RuboCop::Cop::Performance::SortReverse < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SortBlock
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/sort_reverse.rb#22
  def on_block(node); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/sort_reverse.rb#38
  def message(var_a, var_b); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/sort_reverse.rb#20
RuboCop::Cop::Performance::SortReverse::MSG = T.let(T.unsafe(nil), String)

# This cop identifies places where `gsub(/a+/, 'a')` and `gsub!(/a+/, 'a')`
# can be replaced by `squeeze('a')` and `squeeze!('a')`.
#
# The `squeeze('a')` method is faster than `gsub(/a+/, 'a')`.
#
# @example
#
#   # bad
#   str.gsub(/a+/, 'a')
#   str.gsub!(/a+/, 'a')
#
#   # good
#   str.squeeze('a')
#   str.squeeze!('a')
#
# source://rubocop-performance//lib/rubocop/cop/performance/squeeze.rb#21
class RuboCop::Cop::Performance::Squeeze < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/squeeze.rb#41
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/squeeze.rb#32
  def squeeze_candidate?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/squeeze.rb#61
  def repeating_literal?(regex_str); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/squeeze.rb#24
RuboCop::Cop::Performance::Squeeze::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/squeeze.rb#27
RuboCop::Cop::Performance::Squeeze::PREFERRED_METHODS = T.let(T.unsafe(nil), Hash)

# source://rubocop-performance//lib/rubocop/cop/performance/squeeze.rb#25
RuboCop::Cop::Performance::Squeeze::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies unnecessary use of a regex where `String#start_with?` would suffice.
#
# This cop has `SafeMultiline` configuration option that `true` by default because
# `^start` is unsafe as it will behave incompatible with `start_with?`
# for receiver is multiline string.
#
# @example
#   # bad
#   'abc'.match?(/\Aab/)
#   /\Aab/.match?('abc')
#   'abc' =~ /\Aab/
#   /\Aab/ =~ 'abc'
#   'abc'.match(/\Aab/)
#   /\Aab/.match('abc')
#
#   # good
#   'abc'.start_with?('ab')
# @example SafeMultiline: true (default)
#
#   # good
#   'abc'.match?(/^ab/)
#   /^ab/.match?('abc')
#   'abc' =~ /^ab/
#   /^ab/ =~ 'abc'
#   'abc'.match(/^ab/)
#   /^ab/.match('abc')
# @example SafeMultiline: false
#
#   # bad
#   'abc'.match?(/^ab/)
#   /^ab/.match?('abc')
#   'abc' =~ /^ab/
#   /^ab/ =~ 'abc'
#   'abc'.match(/^ab/)
#   /^ab/.match('abc')
#
# source://rubocop-performance//lib/rubocop/cop/performance/start_with.rb#44
class RuboCop::Cop::Performance::StartWith < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RegexpMetacharacter
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/start_with.rb#58
  def on_match_with_lvasgn(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/start_with.rb#58
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/start_with.rb#52
  def redundant_regex?(param0 = T.unsafe(nil)); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/start_with.rb#48
RuboCop::Cop::Performance::StartWith::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/start_with.rb#50
RuboCop::Cop::Performance::StartWith::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies unnecessary use of a regex where
# `String#include?` would suffice.
#
# This cop's offenses are not safe to auto-correct if a receiver is nil.
#
# @example
#   # bad
#   'abc'.match?(/ab/)
#   /ab/.match?('abc')
#   'abc' =~ /ab/
#   /ab/ =~ 'abc'
#   'abc'.match(/ab/)
#   /ab/.match('abc')
#
#   # good
#   'abc'.include?('ab')
#
# source://rubocop-performance//lib/rubocop/cop/performance/string_include.rb#22
class RuboCop::Cop::Performance::StringInclude < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/string_include.rb#34
  def on_match_with_lvasgn(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/string_include.rb#34
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/string_include.rb#28
  def redundant_regex?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/string_include.rb#50
  def literal?(regex_str); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/string_include.rb#25
RuboCop::Cop::Performance::StringInclude::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/string_include.rb#26
RuboCop::Cop::Performance::StringInclude::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies places where `gsub` can be replaced by
# `tr` or `delete`.
#
# @example
#   # bad
#   'abc'.gsub('b', 'd')
#   'abc'.gsub('a', '')
#   'abc'.gsub(/a/, 'd')
#   'abc'.gsub!('a', 'd')
#
#   # good
#   'abc'.gsub(/.*/, 'a')
#   'abc'.gsub(/a+/, 'd')
#   'abc'.tr('b', 'd')
#   'a b c'.delete(' ')
#
# source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#21
class RuboCop::Cop::Performance::StringReplacement < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#38
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#32
  def string_replacement?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#84
  def accept_first_param?(first_param); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#79
  def accept_second_param?(second_param); end

  # source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#60
  def autocorrect(corrector, node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#101
  def first_source(first_param); end

  # source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#144
  def message(node, first_source, second_source); end

  # source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#151
  def method_suffix(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#49
  def offense(node, first_param, second_param); end

  # source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#130
  def range(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#155
  def remove_second_param(corrector, node, first_param); end

  # source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#70
  def replace_method(corrector, node, first_source, second_source, first_param); end

  # source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#134
  def replacement_method(node, first_source, second_source); end

  # source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#119
  def source_from_regex_constructor(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#112
  def source_from_regex_literal(node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#30
RuboCop::Cop::Performance::StringReplacement::BANG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#28
RuboCop::Cop::Performance::StringReplacement::DELETE = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#27
RuboCop::Cop::Performance::StringReplacement::DETERMINISTIC_REGEX = T.let(T.unsafe(nil), Regexp)

# source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#25
RuboCop::Cop::Performance::StringReplacement::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#26
RuboCop::Cop::Performance::StringReplacement::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-performance//lib/rubocop/cop/performance/string_replacement.rb#29
RuboCop::Cop::Performance::StringReplacement::TR = T.let(T.unsafe(nil), String)

# This cop identifies places where custom code finding the sum of elements
# in some Enumerable object can be replaced by `Enumerable#sum` method.
#
# This cop can change auto-correction scope depending on the value of
# `SafeAutoCorrect`.
# Its auto-correction is marked as safe by default (`SafeAutoCorrect: true`)
# to prevent `TypeError` in auto-correced code when initial value is not
# specified as shown below:
#
# [source,ruby]
# ----
# ['a', 'b'].sum # => (String can't be coerced into Integer)
# ----
#
# Therefore if initial value is not specified, unsafe auto-corrected will not occur.
#
# If you always want to enable auto-correction, you can set `SafeAutoCorrect: false`.
#
# [source,yaml]
# ----
# Performance/Sum:
#   SafeAutoCorrect: false
# ----
#
# Please note that the auto-correction command line option will be changed from
# `rubocop -a` to `rubocop -A`, which includes unsafe auto-correction.
#
# @example
#   # bad
#   [1, 2, 3].inject(:+)                        # These bad cases with no initial value are unsafe and
#   [1, 2, 3].inject(&:+)                       # will not be auto-correced by default. If you want to
#   [1, 2, 3].reduce { |acc, elem| acc + elem } # auto-corrected, you can set `SafeAutoCorrect: false`.
#   [1, 2, 3].reduce(10, :+)
#   [1, 2, 3].map { |elem| elem ** 2 }.sum
#   [1, 2, 3].collect(&:count).sum(10)
#
#   # good
#   [1, 2, 3].sum
#   [1, 2, 3].sum(10)
#   [1, 2, 3].sum { |elem| elem ** 2 }
#   [1, 2, 3].sum(10, &:count)
#
# source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#48
class RuboCop::Cop::Performance::Sum < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#77
  def acc_plus_elem?(param0 = T.unsafe(nil), param1, param2); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#77
  def elem_plus_acc?(param0 = T.unsafe(nil), param1, param2); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#89
  def on_block(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#82
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#57
  def sum_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#61
  def sum_map_candidate?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#70
  def sum_with_block_candidate?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#132
  def array_literal?(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#137
  def autocorrect(corrector, init, range); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#145
  def autocorrect_sum_map(corrector, sum, map, init); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#219
  def build_block_bad_method(method, init, var_acc, var_elem, body); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#186
  def build_block_message(send, init, var_acc, var_elem, body); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#192
  def build_good_method(init, block_pass = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#205
  def build_method_bad_method(init, method, operation); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#168
  def build_method_message(node, method, init, operation); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#179
  def build_sum_map_message(method, init); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#127
  def empty_array_literal?(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#104
  def handle_sum_candidate(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#115
  def handle_sum_map_candidate(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#230
  def method_call_with_args_range(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#164
  def sum_block_range(send, node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#160
  def sum_map_range(map, sum); end

  # source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#156
  def sum_method_range(node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#52
RuboCop::Cop::Performance::Sum::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#53
RuboCop::Cop::Performance::Sum::MSG_IF_NO_INIT_VALUE = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/sum.rb#55
RuboCop::Cop::Performance::Sum::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop checks for .times.map calls.
# In most cases such calls can be replaced
# with an explicit array creation.
#
# @example
#   # bad
#   9.times.map do |i|
#   i.to_s
#   end
#
#   # good
#   Array.new(9) do |i|
#   i.to_s
#   end
#
# source://rubocop-performance//lib/rubocop/cop/performance/times_map.rb#20
class RuboCop::Cop::Performance::TimesMap < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/times_map.rb#32
  def on_block(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/times_map.rb#28
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/times_map.rb#58
  def times_map_call(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/times_map.rb#38
  def check(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/times_map.rb#49
  def message(map_or_collect, count); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/times_map.rb#23
RuboCop::Cop::Performance::TimesMap::MESSAGE = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/times_map.rb#25
RuboCop::Cop::Performance::TimesMap::MESSAGE_ONLY_IF = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/times_map.rb#26
RuboCop::Cop::Performance::TimesMap::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# In Ruby 2.3 or later, use unary plus operator to unfreeze a string
# literal instead of `String#dup` and `String.new`.
# Unary plus operator is faster than `String#dup`.
#
# NOTE: `String.new` (without operator) is not exactly the same as `+''`.
# These differ in encoding. `String.new.encoding` is always `ASCII-8BIT`.
# However, `(+'').encoding` is the same as script encoding(e.g. `UTF-8`).
# Therefore, auto-correction is unsafe.
# So, if you expect `ASCII-8BIT` encoding, disable this cop.
#
# @example
#   # bad
#   ''.dup
#   "something".dup
#   String.new
#   String.new('')
#   String.new('something')
#
#   # good
#   +'something'
#   +''
#
# source://rubocop-performance//lib/rubocop/cop/performance/unfreeze_string.rb#27
class RuboCop::Cop::Performance::UnfreezeString < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/unfreeze_string.rb#33
  def dup_string?(param0 = T.unsafe(nil)); end

  # source://rubocop-performance//lib/rubocop/cop/performance/unfreeze_string.rb#44
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/unfreeze_string.rb#37
  def string_new?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-performance//lib/rubocop/cop/performance/unfreeze_string.rb#54
  def string_value(node); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/unfreeze_string.rb#30
RuboCop::Cop::Performance::UnfreezeString::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/unfreeze_string.rb#31
RuboCop::Cop::Performance::UnfreezeString::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# This cop identifies places where `URI::Parser.new`
# can be replaced by `URI::DEFAULT_PARSER`.
#
# @example
#   # bad
#   URI::Parser.new
#
#   # good
#   URI::DEFAULT_PARSER
#
# source://rubocop-performance//lib/rubocop/cop/performance/uri_default_parser.rb#16
class RuboCop::Cop::Performance::UriDefaultParser < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-performance//lib/rubocop/cop/performance/uri_default_parser.rb#29
  def on_send(node); end

  # source://rubocop-performance//lib/rubocop/cop/performance/uri_default_parser.rb#23
  def uri_parser_new?(param0 = T.unsafe(nil)); end
end

# source://rubocop-performance//lib/rubocop/cop/performance/uri_default_parser.rb#19
RuboCop::Cop::Performance::UriDefaultParser::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-performance//lib/rubocop/cop/performance/uri_default_parser.rb#21
RuboCop::Cop::Performance::UriDefaultParser::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Common functionality for handling regexp metacharacters.
#
# source://rubocop-performance//lib/rubocop/cop/mixin/regexp_metacharacter.rb#6
module RuboCop::Cop::RegexpMetacharacter
  private

  # source://rubocop-performance//lib/rubocop/cop/mixin/regexp_metacharacter.rb#63
  def drop_end_metacharacter(regexp_string); end

  # source://rubocop-performance//lib/rubocop/cop/mixin/regexp_metacharacter.rb#55
  def drop_start_metacharacter(regexp_string); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/mixin/regexp_metacharacter.rb#15
  def literal_at_end?(regexp); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/mixin/regexp_metacharacter.rb#41
  def literal_at_end_with_backslash_z?(regex_str); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/mixin/regexp_metacharacter.rb#48
  def literal_at_end_with_dollar?(regex_str); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/mixin/regexp_metacharacter.rb#9
  def literal_at_start?(regexp); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/mixin/regexp_metacharacter.rb#21
  def literal_at_start_with_backslash_a?(regex_str); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/mixin/regexp_metacharacter.rb#31
  def literal_at_start_with_caret?(regex_str); end

  # @return [Boolean]
  #
  # source://rubocop-performance//lib/rubocop/cop/mixin/regexp_metacharacter.rb#71
  def safe_multiline?; end
end

# Common functionality for cops checking `Enumerable#sort` blocks.
#
# source://rubocop-performance//lib/rubocop/cop/mixin/sort_block.rb#6
module RuboCop::Cop::SortBlock
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop-performance//lib/rubocop/cop/mixin/sort_block.rb#17
  def replaceable_body?(param0 = T.unsafe(nil), param1, param2); end

  # source://rubocop-performance//lib/rubocop/cop/mixin/sort_block.rb#10
  def sort_with_block?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-performance//lib/rubocop/cop/mixin/sort_block.rb#23
  def sort_range(send, node); end
end

# source://rubocop/1.39.0/lib/rubocop/ast_aliases.rb#5
RuboCop::NodePattern = RuboCop::AST::NodePattern

# RuboCop Performance project namespace
#
# source://rubocop-performance//lib/rubocop/performance.rb#5
module RuboCop::Performance; end

# source://rubocop-performance//lib/rubocop/performance.rb#8
RuboCop::Performance::CONFIG = T.let(T.unsafe(nil), Hash)

# source://rubocop-performance//lib/rubocop/performance.rb#7
RuboCop::Performance::CONFIG_DEFAULT = T.let(T.unsafe(nil), Pathname)

# Because RuboCop doesn't yet support plugins, we have to monkey patch in a
# bit of our configuration.
#
# source://rubocop-performance//lib/rubocop/performance/inject.rb#7
module RuboCop::Performance::Inject
  class << self
    # source://rubocop-performance//lib/rubocop/performance/inject.rb#8
    def defaults!; end
  end
end

# source://rubocop-performance//lib/rubocop/performance.rb#6
RuboCop::Performance::PROJECT_ROOT = T.let(T.unsafe(nil), Pathname)

# This module holds the RuboCop Performance version information.
#
# source://rubocop-performance//lib/rubocop/performance/version.rb#6
module RuboCop::Performance::Version
  class << self
    # source://rubocop-performance//lib/rubocop/performance/version.rb#9
    def document_version; end
  end
end

# source://rubocop-performance//lib/rubocop/performance/version.rb#7
RuboCop::Performance::Version::STRING = T.let(T.unsafe(nil), String)

# source://rubocop/1.39.0/lib/rubocop/ast_aliases.rb#6
RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

# source://rubocop/1.39.0/lib/rubocop/ast_aliases.rb#7
RuboCop::Token = RuboCop::AST::Token
